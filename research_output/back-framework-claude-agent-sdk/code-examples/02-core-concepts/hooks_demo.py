"""
02-core-concepts/hooks_demo.py
--------------------------------
Demonstrates the hook system for intercepting agent lifecycle events.

Shows:
  - PreToolUse: Run logic before any tool executes
  - PostToolUse: Run logic after a tool completes
  - Blocking a tool use from a hook
  - Modifying tool input from a hook
  - Logging with hooks

Run:
  python hooks_demo.py
"""

import asyncio
import json
import time
from claude_agent_sdk import (
    query,
    ClaudeAgentOptions,
    HookMatcher,
    AssistantMessage,
    TextBlock,
    ResultMessage,
)


# ─────────────────────────────────────────────
# Hook functions
# ─────────────────────────────────────────────

# Global log for demonstration
execution_log = []


async def log_tool_use(input_data: dict, tool_use_id: str, context) -> dict:
    """
    Logs every tool call with timing.
    Hooks receive: (input_data, tool_use_id, context)
    Must return a dict (empty dict = no modification).
    """
    tool_name = input_data.get("tool_name", "unknown")
    tool_input = input_data.get("tool_input", {})

    log_entry = {
        "timestamp": time.time(),
        "tool": tool_name,
        "input_preview": str(tool_input)[:100],
    }
    execution_log.append(log_entry)
    print(f"  [PreToolUse] → {tool_name}: {str(tool_input)[:60]}")

    return {}  # Empty dict = don't block, don't modify


async def log_tool_result(input_data: dict, tool_use_id: str, context) -> dict:
    """
    Logs the result of each tool call.
    PostToolUse input_data contains both input and output.
    """
    tool_name = input_data.get("tool_name", "unknown")
    output = input_data.get("tool_output", {})

    print(f"  [PostToolUse] ← {tool_name}: result preview: {str(output)[:60]}")
    return {}


async def block_writes_outside_output(input_data: dict, tool_use_id: str, context) -> dict:
    """
    Safety hook: only allow Write tool inside the output/ directory.
    To block a tool, return a dict with hookSpecificOutput.
    """
    tool_name = input_data.get("tool_name", "")
    if tool_name in ("Write", "Edit"):
        file_path = input_data.get("tool_input", {}).get("file_path", "")

        if file_path and not file_path.startswith("output/"):
            print(f"  [BLOCKED] {tool_name} to '{file_path}' — must write to output/")
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": (
                        f"File writes are only allowed in output/ directory. "
                        f"Attempted: {file_path}"
                    ),
                }
            }

    return {}  # Allow everything else


async def add_safety_note_to_writes(input_data: dict, tool_use_id: str, context) -> dict:
    """
    Demonstration: modify tool input before execution.
    Prepends a safety comment to every Python file being written.
    """
    tool_name = input_data.get("tool_name", "")
    if tool_name == "Write":
        tool_input = input_data.get("tool_input", {})
        file_path = tool_input.get("file_path", "")

        if file_path.endswith(".py"):
            original_content = tool_input.get("content", "")
            safety_header = "# Auto-generated by Claude Agent SDK\n# Review before deploying to production\n\n"
            modified_content = safety_header + original_content

            print(f"  [Hook] Prepending safety header to {file_path}")
            # Return modified input — this changes what Claude actually writes
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "updatedInput": {
                        **tool_input,
                        "content": modified_content,
                    }
                }
            }

    return {}


async def audit_bash_commands(input_data: dict, tool_use_id: str, context) -> dict:
    """
    Audit hook: Block specific dangerous bash patterns.
    """
    tool_name = input_data.get("tool_name", "")
    if tool_name == "Bash":
        command = input_data.get("tool_input", {}).get("command", "")
        dangerous = ["rm -rf /", "sudo rm -rf", "mkfs", "dd if=/dev/zero"]

        for pattern in dangerous:
            if pattern in command:
                print(f"  [SECURITY] Blocked dangerous bash: '{command[:60]}'")
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PreToolUse",
                        "permissionDecision": "deny",
                        "permissionDecisionReason": f"Dangerous pattern '{pattern}' blocked by security hook",
                    }
                }

    return {}


# ─────────────────────────────────────────────
# Main demo
# ─────────────────────────────────────────────
async def main():
    print("=== Hooks Demo ===\n")
    print("Hooks registered:")
    print("  PreToolUse  (all tools):  log_tool_use")
    print("  PreToolUse  (Write/Edit): block_writes_outside_output")
    print("  PreToolUse  (Write):      add_safety_note_to_writes")
    print("  PreToolUse  (Bash):       audit_bash_commands")
    print("  PostToolUse (all tools):  log_tool_result")
    print()

    from pathlib import Path
    Path("output").mkdir(exist_ok=True)

    options = ClaudeAgentOptions(
        allowed_tools=["Read", "Write", "Bash", "Glob"],
        permission_mode="acceptEdits",
        hooks={
            "PreToolUse": [
                # The "*" matcher matches ALL tools
                HookMatcher(matcher="*", hooks=[log_tool_use]),
                # Specific matchers override behavior for specific tools
                HookMatcher(matcher="Write|Edit", hooks=[block_writes_outside_output]),
                HookMatcher(matcher="Write", hooks=[add_safety_note_to_writes]),
                HookMatcher(matcher="Bash", hooks=[audit_bash_commands]),
            ],
            "PostToolUse": [
                HookMatcher(matcher="*", hooks=[log_tool_result]),
            ],
        },
    )

    async for message in query(
        prompt=(
            "Do three things: "
            "1. Run `echo 'Hook demo running'` in bash. "
            "2. Create output/demo.py with a simple hello world function. "
            "3. Try to create /tmp/unauthorized.txt (this should be blocked). "
            "Report what happened."
        ),
        options=options,
    ):
        if isinstance(message, AssistantMessage):
            for block in message.content:
                if isinstance(block, TextBlock):
                    print(block.text, end="", flush=True)

        elif isinstance(message, ResultMessage):
            print(f"\n\n{'=' * 50}")
            print(f"Session complete! Cost: ${message.total_cost_usd:.4f}")
            print(f"\nExecution log ({len(execution_log)} tool calls):")
            for entry in execution_log:
                print(f"  {entry['tool']}: {entry['input_preview'][:60]}")


asyncio.run(main())
